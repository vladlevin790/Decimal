#include "s21_decimal.h"

#include <math.h>
#include <stdio.h>

#include "binary/s21_binary.h"
#include "decimal_helper/s21_decimal_helper.h"




int get_decimal_sign(s21_decimal decimal) {
    return s21_get_bit(decimal.bits[3], 31);
}

int get_decimal_exponent(s21_decimal decimal) {
    return s21_get_range_bits(decimal.bits[3], 16, 23);
}

void set_decimal_sign(s21_decimal* decimal, int sign) {
    if (sign == 0) {
        decimal->bits[3] = s21_clear_bit(decimal->bits[3], 31);
    } else {
        decimal->bits[3] = s21_set_bit(decimal->bits[3], 31);
    }
}

void set_decimal_exponent(s21_decimal* decimal, int exponent) {
    if (exponent < 0 || exponent > 28) {
        return;
    }

    for (int i = 0; i < 8; i++) {
        if (s21_get_bit(exponent, i)) {
            decimal->bits[3] = s21_set_bit(decimal->bits[3], 16 + i);
        } else {
            decimal->bits[3] = s21_clear_bit(decimal->bits[3], 16 + i);
        }
    }
}

int get_bit(s21_decimal number, int bit) {
  int sign;
  if ((number.bits[bit / 32] & (1 << bit % 32)) == 0) {
    sign = 0;
  } else {
    sign = 1;
  }
  return sign;
}

void set_bit(s21_decimal *number, int bit, int sign) {
  if (sign == 0) {
    number->bits[bit / 32] = number->bits[bit / 32] & ~(1 << bit % 32);
  } else {
    number->bits[bit / 32] = number->bits[bit / 32] | (1 << bit % 32);
  }
}

void initial_num(s21_decimal *number) {
  for (int i = 0; i < 128; i++) {
    set_bit(number, i, 0);
  }
}

int s21_from_int_to_decimal(int src, s21_decimal *dst) {
    if (dst == s21_NULL) {
        return 1;
    }

    clear_decimal(dst);
    set_decimal_sign(dst, src < 0);
    set_decimal_exponent(dst, 0);

    int is_min_value = src == INT_MIN;

    if (src < 0) {
        src += is_min_value; // Добавляем 1, чтобы не выйти за пределы int
        src *= -1;
    }
    
    for (int i = 0; i < 31; i++) {
        set_decimal_digit_by_index(dst, i, s21_get_bit(src, i));
    }

    // Если число == INT_MIN, то добавляем 1
    if (is_min_value) {
        s21_decimal tmp_decimal = get_new_decimal();
        tmp_decimal.bits[0] = s21_set_bit(tmp_decimal.bits[0], 0);

        // TODO: s21_add(*dst, tmp_decimal, dst);
    }

    return 0;
}

int s21_is_less_simple(s21_decimal dec1, s21_decimal dec2) {
  int is_less = FALSE;
  for (int i = 95; i >= 0; i--) {
    if (get_bit(dec1, i) ^ get_bit(dec2, i)) {
      is_less = get_bit(dec2, i);
      break;
    }
  }

  return is_less;
}

int s21_is_equal(s21_decimal value_1, s21_decimal value_2){
    int result_code = 0;

    if (value_1.bits[0] == 0 && value_1.bits[1] == 0
        && value_1.bits[2] == 0 && value_2.bits[0] == 0
        && value_2.bits[1] == 0 && value_2.bits[2] == 0) {
        result_code = 1;
    } else {
        int exponent_1 = get_decimal_exponent(value_1);
        int exponent_2 = get_decimal_exponent(value_2);

        int sign_1 = get_decimal_sign(value_1);
        int sign_2 = get_decimal_sign(value_2);

        result_code = value_1.bits[0] == value_2.bits[0]
            && value_1.bits[1] == value_2.bits[1]
            && value_1.bits[2] == value_2.bits[2]
            && exponent_1 == exponent_2
            && sign_1 == sign_2;
    }

    return result_code;
}

int s21_is_less_or_equal_simple(s21_decimal dec1, s21_decimal dec2) {
  return s21_is_less_simple(dec1, dec2) || s21_is_equal(dec1, dec2);
}

int s21_is_greater_simple(s21_decimal dec1, s21_decimal dec2) {
  return !s21_is_less_or_equal_simple(dec1, dec2);
}

int s21_is_greater_or_equal_simple(s21_decimal dec1, s21_decimal dec2) {
  return s21_is_greater_simple(dec1, dec2) || s21_is_equal(dec1, dec2);
}

int s21_add_simple(s21_decimal dec1, s21_decimal dec2, s21_decimal *result) {
  initial_num(result);
  int rank = 0;
  for (int i = 0; i < 96; i++) {
    int bit_dec1 = get_bit(dec1, i);
    int bit_dec2 = get_bit(dec2, i);

    set_bit(result, i, bit_dec1 ^ bit_dec2 ^ rank);

    rank = (bit_dec1 && bit_dec2) || (bit_dec1 && rank) || (bit_dec2 && rank);
  }

  return rank;
}

void s21_sub_simple(s21_decimal dec1, s21_decimal dec2, s21_decimal *result) {
  initial_num(result);
  for (int i = 0; i < 96; i++) {
    int bit_dec1 = get_bit(dec1, i);
    int bit_dec2 = get_bit(dec2, i);

    set_bit(result, i, bit_dec1 ^ bit_dec2);

    if (!bit_dec1 && bit_dec2) {
      int k = i + 1;
      while ((bit_dec1 = get_bit(dec1, k)) != 1) {
        set_bit(&dec1, k, 1);
        k++;
      }
      set_bit(&dec1, k, 0);
    }
  }
}

int shift_left(s21_decimal *number) {
  int is_overflow = get_bit(*number, 95);
  for (int i = 95; i >= 0; i--) {
    if (i != 0) {
      set_bit(number, i, get_bit(*number, i - 1));
    } else {
      set_bit(number, i, 0);
    }
  }
  return is_overflow;
}

int shift_right(s21_decimal *number) {
  int is_overflow = get_bit(*number, 1);
  for (int i = 0; i < 96; i++) {
    if (i != 95) {
      set_bit(number, i, get_bit(*number, i + 1));
    } else {
      set_bit(number, i, 0);
    }
  }
  return is_overflow;
}

int s21_mul_simple(s21_decimal dec1, s21_decimal dec2, s21_decimal *result) {
  s21_decimal tmp;
  initial_num(&tmp);
  int is_owerfull = 0;
  for (int i = 0; i < 96 && !is_owerfull; i++) {
    if (get_bit(dec2, i) == 1) {
      s21_decimal temp = dec1;
      int k = 0;
      while (k < i) {
        if (shift_left(&temp)) {
          is_owerfull = 1;
          break;
        }
        k++;
      }
      if (is_owerfull || (is_owerfull = s21_add_simple(temp, tmp, &tmp))) {
        break;
      }
    }
  }

  if (!is_owerfull)
    *result = tmp;

  return is_owerfull;
}

s21_decimal s21_div_simple(s21_decimal dec1, s21_decimal dec2,
                           s21_decimal *result) {
  if (result)
    initial_num(result);
  s21_decimal fmod = {0};
  s21_decimal temp = {0};
  if (s21_is_greater_or_equal_simple(dec1, dec2))
    set_bit(&temp, 0, 1);
  if (!s21_is_greater_simple(dec2, dec1)) {
    while (1) {
      s21_decimal copy_dec2 = dec2;
      while (s21_is_greater_or_equal_simple(dec1, copy_dec2) &&
             !(get_bit(dec1, 95) && get_bit(copy_dec2, 95))) {
        shift_left(&copy_dec2);
        shift_left(&temp);
      }

      if (!(get_bit(dec1, 95) && get_bit(copy_dec2, 95)) ||
          (s21_is_greater_or_equal_simple(copy_dec2, dec1))) {
        shift_right(&copy_dec2);
        shift_right(&temp);
      }

      s21_sub_simple(dec1, copy_dec2, &dec1);
      if (result)
        s21_add_simple(*result, temp, result);
      initial_num(&temp);
      set_bit(&temp, 0, 1);
      if (s21_is_less_simple(dec1, dec2)) {
        break;
      }
    }
  }
  fmod = dec1;
  return fmod;
}

void s21_bank_rounding(s21_decimal *value, int count) {
  int system_bit = value->bits[3];
  int exp = get_decimal_exponent(*value) - count;
  while (count > 0) {
    s21_decimal base = {0}, one = {0}, two = {0}, two_res = {0};
    s21_from_int_to_decimal(10, &base);
    s21_from_int_to_decimal(1, &one);
    s21_from_int_to_decimal(2, &two);
    s21_decimal dec_mod = s21_div_simple(*value, base, value);
    if (dec_mod.bits[0] > 5) {
      s21_add_simple(*value, one, value);
    } else if (dec_mod.bits[0] == 5) {
      two_res = s21_div_simple(*value, two, NULL);
      if (s21_is_equal(one, two_res))
        s21_add_simple(*value, one, value);
    }
    count--;
  }
  value->bits[3] = system_bit;
  set_decimal_exponent(value, exp);
}

void normalize(s21_decimal *dec1, s21_decimal *dec2) {
  int scl1 = get_decimal_exponent(*dec1);
  int scl2 = get_decimal_exponent(*dec2);

  int v1 = dec1->bits[3];
  int v2 = dec2->bits[3];

  int min_scl = (scl1 < scl2) ? scl1 : scl2;
  int max_scl = (scl1 > scl2) ? scl1 : scl2;
  s21_decimal *min_val = (scl1 < scl2) ? dec1 : dec2;
  s21_decimal *max_val = (scl1 > scl2) ? dec1 : dec2;
  s21_decimal ten;
  s21_from_int_to_decimal(10, &ten);

  while (min_scl != max_scl) {
    if (min_scl < 28 && !s21_mul_simple(*min_val, ten, min_val)) {
      min_scl++;
      set_decimal_exponent(min_val, min_scl);
    } else {
      s21_bank_rounding(max_val, max_scl - min_scl);
      break;
    }
  }

  dec1->bits[3] = v1;
  dec2->bits[3] = v2;
  set_decimal_exponent(min_val, min_scl);
  set_decimal_exponent(max_val, min_scl);
}

int s21_add(s21_decimal dec1, s21_decimal dec2, s21_decimal *result) {
  int add_res_code = S21_DECIMAL_OK;

  normalize(&dec1, &dec2);
  int exp = get_decimal_exponent(dec1);
  int sign_1 = get_decimal_sign(dec1);
  int sign_2 = get_decimal_sign(dec2);

  if (!(sign_1 ^ sign_2)) {
    add_res_code = s21_add_simple(dec1, dec2, result);
    set_decimal_sign(result, sign_1);
    if (add_res_code && sign_1 && sign_2) {
      add_res_code = ERROR_UNDERFLOW;
    }
  } else if (s21_is_less_or_equal_simple(dec1, dec2)) {
    s21_sub_simple(dec2, dec1, result);
    set_decimal_sign(result, sign_2);
  } else {
    s21_sub_simple(dec1, dec2, result);
    set_decimal_sign(result, sign_1);
  }

  if (add_res_code && get_decimal_exponent(dec1)) {
    s21_bank_rounding(&dec1, 1);
    s21_bank_rounding(&dec2, 1);
    add_res_code = s21_add(dec1, dec2, result);
  } else {
    set_decimal_exponent(result, exp);
  }

  return add_res_code;
}

///////////////////////////////////////////////////////////////////////////
// void print_binary(int num){
//     for(int i=31; i>=0; i--){
//         printf("%d", (num>>i) &1);
//         // if (i%32 == 0){
//         //     printf("\n");
//         // }
//         // if i ==2 сдвиг вправо 00001010 >> 00000010
//         // было 2^1 + 2^3 = 10
//         // стало 2^1 = 2
//         // 00000010 & 1 = 00000010 & 00000001 = 0
//     }
//     printf("\n");
// }

// void print_decimal(s21_decimal num ) {
//     for (int i = 3; i >=0; i--) {
//         print_binary(num.bits[i]);
//         // printf("%d", num.bits[i]);
//         // if (i != 0) {
//         //     printf(".");
//         // }

//     }
//     printf("\n");
// }

// void print_decimal_to_int(s21_decimal num) {
//     for (int i = 0; i <4; i++){
//         printf("%d : ", num.bits[i]);
//     }
//     printf("\n");
// }

// int main() {
//     // int num;
//     // printf("Enter a number: ");
//     // scanf("%d", &num);
//     // print_binary(num);

//     // s21_decimal num = {1, 1, 1, 0};  // 2^1 + 2^32 +2^64 = ...
//     // bits[3] 10000000 00000011 00000000 00000000 = 2^16 + 2^17 + 2^31 =...
//     // первый 10000000 значит что отрицательное число
//     // второй 00000011 равен 10^3
//     // третий и четвертый всегда нули иначе неверное.
//     // в итоге мы получаем некое число = 2^16 + 2^17 + 2^31 в котором
//     записана экспонента и знак
//     // можно устанавливать знак и экспоненту через функции
//     // set_sing(&num, 1); // устанавливаем знак - отрицательный
//     // set_scale(&num, 3); // устанавливаем экспоненту
//     // либо можно записать в bits[3]-2147287040 это будет значить что мы
//     установили знак минус и экспоненту равную 3
//     // т.е  s21_decimal num = {1, 1, 1, -2147287040}
//     // также можно записывать в виде бита {0b0000001111100001, 1, 1,
//     -2147287040}

//     s21_decimal num =  {{1742750924, -765097718, 2020532269, 720896}};
//     // set_sign(&num, 1);
//     print_decimal(num);
//     print_decimal_to_int(num);

//     s21_decimal num2 = {{-1135548987, -1729193528, 1968365552, -2146238464}};
//     // set_sign(&num2, 1);
//     // set_scale(&num2, 3);
//     print_decimal(num2);
//     print_decimal_to_int(num2);

// //   s21_decimal num_1 = {{1742750924, -765097718, 2020532269, 720896}};
// //   s21_decimal num_2 = {{-1135548987, -1729193528, 1968365552,
// -2146238464}};
// //   s21_decimal result = {0};
// //   s21_decimal expected = {{-1640015172, 593591452, 2020532250, 720896}};

//     s21_decimal res_sum = {0};
//     s21_add(num, num2, &res_sum);
//     print_decimal(res_sum);
//     print_decimal_to_int(res_sum);

//     return 0;
// }
